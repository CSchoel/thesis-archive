<!DOCTYPE html>
<html>
<head>
	<title>Nonpacemaker action potential of myocytes</title>
	<meta charset="UTF-8"/>
	<script src="../lib/jquery-2.2.0.js"></script>
	<script src="../lib/snap.svg.js"></script>
	<script src="../js/channel_anim.js"></script>
	<script src="../lib/pathseg.js"></script> <!-- polyfill to use pathSegList that chrome has deprecated -->
	<script type="text/javascript">
		/*
		 * General Note: In images added with Snap.load(...), element.attr("id") will give a generated id while
		 * element.node.id will give the original id of the node from the loaded document.
		 */

		var t0 = 0;
		var tend = 300;
		var animDur = 10000;
		var tglob = 0;
		var startPaths = {};
		var endPaths = {};
		var animPaths = {};
		var pOffs = {};
		var rot_centers = {};
		var sglob;
		var anim = null;
		var slider;
		
		setStartStates = function(im) {
			findAndStore(im, startPaths, "t", "time0");
			findAndStore(im, endPaths, "t", "time300");

			//cal
			findAndStore(im, startPaths, "cal_l", "cal_l");
			findAndStore(im, endPaths, "cal_l", "cal_lo");
			findAndStore(im, startPaths, "cal_r", "cal_r");
			findAndStore(im, endPaths, "cal_r", "cal_ro");
			findAndStoreP(im, "calIp_", 20, 20);

			//ir
			animPaths["spermine"] = deepcopy(im.select("#spermine_path"));
			findAndStoreP(im, "irIp_", 20, 20);

			//to
			findAndStore(im, startPaths, "to_l", "to_l");
			findAndStore(im, endPaths,   "to_l", "to_lo");
			findAndStore(im, startPaths, "to_r", "to_r");
			findAndStore(im, endPaths,   "to_r", "to_ro");
			findAndStore(im, startPaths, "to_c", "to_c");
			findAndStore(im, endPaths,   "to_c", "to_ci");
			animPaths["to_b"] = deepcopy(im.select("#to_bp"));
			findAndStoreP(im, "toIp_", 2, 2);

			//dr
			makeAbs(im.select("#dr_l"));
			makeAbs(im.select("#dr_r"));
			makeAbs(im.select("#dr_lio"));
			makeAbs(im.select("#dr_rio"));
			findAndStore(im, startPaths, "dr_l", "dr_l");
			findAndStore(im, endPaths,   "dr_l", "dr_lio");
			findAndStore(im, startPaths, "dr_r", "dr_r");
			findAndStore(im, endPaths,   "dr_r", "dr_rio");
			findAndStoreP(im, "drIp_", 10, 10);

			//naka
			rot_centers["naka_l"] = [im.select("#nakaR_l").attr("cx"), im.select("#nakaR_l").attr("cy")];
			rot_centers["naka_r"] = [im.select("#nakaR_r").attr("cx"), im.select("#nakaR_r").attr("cy")];
			findAndStore(im, startPaths, "naka_l", "naka_l");
			findAndStore(im, endPaths,   "naka_l", "naka_lc");
			findAndStore(im, startPaths, "naka_r", "naka_r");
			findAndStore(im, endPaths,   "naka_r", "naka_rc");
			findAndStoreP(im, "nakaIp_ko_", 0, 0);
			findAndStoreP(im, "nakaIp_nai_", 0, 0);
			findAndStoreP(im, "nakaIp_ki_", 0, 0);
			findAndStoreP(im, "nakaIp_nao_", 0, 0);
			animPaths["naka_ppi"] = deepcopy(im.select("#naka_ppi"));
			animPaths["naka_ppo"] = deepcopy(im.select("#naka_ppo"));


			//nacae
			rot_centers["nacae_p"] = [im.select("#nacaeR_p").attr("cx"), im.select("#nacaeR_p").attr("cy")];
			findAndStoreP(im, "nacaeIp_cai_", 0, 0);
			findAndStoreP(im, "nacaeIp_cao_", 0, 0);
			findAndStoreP(im, "nacaeIp_nai_", 0, 0);
			findAndStoreP(im, "nacaeIp_nao_", 0, 0);

			//kl
			findAndStoreP(im, "klIp_", 20, 20);

			//caap
			findAndStore(im, startPaths, "caap_l", "caap_l");
			findAndStore(im, endPaths,   "caap_l", "caap_lo");
			findAndStore(im, startPaths, "caap_r", "caap_r");
			findAndStore(im, endPaths,   "caap_r", "caap_ro");
			findAndStoreP(im, "caapIp_", 20, 20);
			animPaths["caap_ca"] = deepcopy(im.select("#caap_cap"));
		}

		findAndStoreP = function(image, prefix, noff, roff) {
			forEachWithId(image, prefix, function(el) {
				animPaths[el.node.id] = deepcopy(el);
				if (noff > 0) {
					pOffs[el.node.id] = periodOffsets(noff, roff);
				}
			});
		}
		
		// l-type calcium channels
		cal = function(im, t) {
			var lid = im.select("#cal_lid");
			var hinge = [lid.attr("x"), lid.attr("y")];
			var act = [7, 17, 200, 210]
			var inact = [17, 167, 200, 350]
			var maxOpenIn = 150;
			var pact = rectRamp(t, act);
			var pinact = rectRamp(t, inact);
			var deg = (1 - pinact) * maxOpenIn;
			lid.attr({transform: "r"+deg+" "+hinge[0]+" "+hinge[1]});

			morph(pact, im.select("#cal_l").node.pathSegList, startPaths["cal_l"], endPaths["cal_l"]);
			morph(pact, im.select("#cal_r").node.pathSegList, startPaths["cal_r"], endPaths["cal_r"]);

			var ionPer = periods(17, 150, 5);
			moveIons(im, t, ionPer, "calIp_", "calI_");
		}

		// inward rectifier
		ir = function(im, t) {
			var sp = im.select("#spermine");
			var spp = animPaths["spermine"];
			var act = [6, 16, 200, 210];
			var pact = rectRamp(t, act);
			pact = 1 - pact;

			var l = spp.getTotalLength() * pact;
			var p = spp.getPointAtLength(l);
			sp.node.pathSegList.getItem(0).x = p.x;
			sp.node.pathSegList.getItem(0).y = p.y;
			sp.attr("transform", "r "+(p.alpha+90));

			var ionPer = periods(220, 350, 5);
			ionPer.unshift([2,10]);
			moveIons(im, t, ionPer, "irIp_", "irI_");
		}

		// transient outward
		to = function(im, t) {
			var ball = im.select("#to_b");
			var ball_path = animPaths["to_b"];
			var act = [8, 12, 182, 186];
			var inact = [8, 32, 182, 205];
			var pact = rectRamp(t, act);
			var pinact = rectRamp(t, inact);

			// move ball
			var l = ball_path.getTotalLength() * pinact;
			var p = ball_path.getPointAtLength(l);
			ball.attr({cx: p.x, cy: p.y});

			// morph chain
			morph(pinact, im.select("#to_c").node.pathSegList, startPaths["to_c"], endPaths["to_c"]);
			// morph activation gates
			morph(pact, im.select("#to_l").node.pathSegList, startPaths["to_l"], endPaths["to_l"]);
			morph(pact, im.select("#to_r").node.pathSegList, startPaths["to_r"], endPaths["to_r"]);

			var ionPer = periods(10, 30, 2);
			moveIons(im, t, ionPer, "toIp_", "toI_");
		}

		// delayed rectifier
		dr = function(im, t) {
			var closed_ni_l = startPaths["dr_l"];
			var closed_ni_r = startPaths["dr_r"];
			var open_i_l = endPaths["dr_l"];
			var open_i_r = endPaths["dr_r"];
			var act = [8, 108, 185, 285];
			var inact = [8, 13, 185, 190];
			var pact = rectRamp(t, act);
			var pinact = rectRamp(t, inact);

			var pore_l = im.select("#dr_l").node.pathSegList;
			var pore_r = im.select("#dr_r").node.pathSegList;

			morphPoint(pact, pore_l, closed_ni_l, open_i_l, 3);
			morphPoint(pact, pore_l, closed_ni_l, open_i_l, 4);
			morphPoint(pinact, pore_l, closed_ni_l, open_i_l, 5);
			morphPoint(pinact, pore_l, closed_ni_l, open_i_l, 6);
			morphPoint(pact, pore_r, closed_ni_r, open_i_r, 3);
			morphPoint(pact, pore_r, closed_ni_r, open_i_r, 4);
			morphPoint(pinact, pore_r, closed_ni_r, open_i_r, 5);
			morphPoint(pinact, pore_r, closed_ni_r, open_i_r, 6);

			var ionPer = periods(190, 280, 3);
			moveIons(im, t, ionPer, "drIp_", "drI_");
		}

		//na+/k+-ATPase
		naka = function(im, t) {
			var ACC_NA = 0; // phase 0: release potassium and accept intracellular sodium
			var ROT_NA = 1; // phase 1: rotate from inside to outside
			var ACC_K  = 2; // phase 2: release sodium and accept extracellular potassium
			var ROT_K  = 3; // phase 3: rotate from outside to inside
			var cdur = 50; // cycle duration
			var pdur = cdur / 4.0; // phase duration
			var cphase = t % cdur;
			var phase = Math.floor(cphase / pdur);
			var pphase = (cphase % pdur) / (pdur-1);
			pphase = clip01(pphase);
			var poreLeft = im.select("#naka_l");
			var poreRight = im.select("#naka_r");
			var phosphorSite = im.select("#naka_ps");
			var poreAngleMax = 20;
			var poreAngle;
			var naClose;
			var kClose;
			var naPath;
			var naPer;
			var kPath;
			var kPer;
			var pPath;
			var pPer;
			if (phase == ACC_NA) {
				// pore is opened towards cytoplasm
				poreAngle = poreAngleMax;
				// potassium moves out of pore, sodium moves into pore, phosphor moves towards binding site
				kPath = "nakaIp_ko"; // potassium outward path
				kPer = pphase;
				naPath = "nakaIp_nai"; // sodium inward path
				naPer = pphase;
				pPath = "naka_ppi"; // phosphor inward path
				pPer = pphase;
				// sodium sites open, potassium sites close
				naClose = (1 - pphase);
				kClose = pphase;
			} else if (phase == ROT_NA) {
				// pore switches opening from inward to outward
				poreAngle = 2 * (0.5 - pphase) * poreAngleMax;
				// sodium stays in the ATPAse, potassium stays out of the pore, phosphor stays at binding site
				kPath = "nakaIp_ko"; // potassium outward path
				kPer = 1;
				naPath = "nakaIp_nai"; // sodium inward path
				naPer = 1;
				pPath = "naka_ppi"; // phosphor inward path
				pPer = 1;
				// sodium sites stay open, potassium sites stay closed
				naClose = 0;
				kClose = 1;

			} else if (phase == ACC_K) {
				// pore stays open towards the outside
				poreAngle = -poreAngleMax;
				// potassium moves into pore, sodium moves out of pore, phosphor stays at binding site
				kPath = "nakaIp_ki"; // potassium inward path
				kPer = pphase;
				naPath = "nakaIp_nao"; // sodium outward path
				naPer = pphase;
				pPath = "naka_ppi"; // phosphor inward path
				pPer = 1;
				// sodium sites close, potassium sites open
				naClose = pphase;
				kClose = (1-pphase);
			} else if (phase == ROT_K) {
				// pore switches opening from outward to inward
				poreAngle = 2 * (pphase - 0.5) * poreAngleMax;
				// potassium stays in the pore, sodium stays outside the pore, phosphor moves away from binding site
				kPath = "nakaIp_ki"; // potassium inward path
				kPer = 1;
				naPath = "nakaIp_nao"; // sodium outward path
				naPer = 1;
				pPath = "naka_ppo"; // phosphor outward path
				pPer = pphase;
				// sodium sites stay closed, potassium sites stay open
				naClose = 1;
				kClose = 0;
			}

			// roate pores and phosphor binding site
			var tr = "r "+(-poreAngle)+" "+rot_centers["naka_r"].join(",");
			poreLeft.attr("transform", "r "+(poreAngle)+" "+rot_centers["naka_l"].join(","));
			phosphorSite.attr("transform", tr);
			poreRight.attr("transform", tr);

			// open/close binding sites
			morph(naClose, im.select("#naka_l").node.pathSegList, startPaths["naka_l"], endPaths["naka_l"]);
			morph(kClose, im.select("#naka_r").node.pathSegList, startPaths["naka_r"], endPaths["naka_r"]);

			// move ions
			moveIonsSingle(im, naPer, naPath+"_", "nakaI_na_");
			moveIonsSingle(im, kPer, kPath+"_", "nakaI_k_");
			
			// move phosphor
			setOnPath(pPer, im.select("#naka_p"), animPaths[pPath]);
			
			var rl = "r "+(poreAngle - poreAngleMax)+" "+rot_centers["naka_l"].join(",");
			var rr = "r "+(-poreAngle + poreAngleMax)+" "+rot_centers["naka_r"].join(",");
			if (phase == ROT_NA) {
				// sodium ions are in the pore => have to be rotated with pore
				transformIons(im, "nakaI_na_", rl);
			}

			if (phase == ROT_K) {
				// potassium ions are in the pore => have to be rotated with pore
				var rot = "r "+(-poreAngle - poreAngleMax)+" "+rot_centers["naka_r"].join(",");
				transformIons(im, "nakaI_k_", rot);
			}

			if (phase == ROT_NA || phase == ACC_K) {
				// phosphor is bound to pore => has to be rotated with pore
				im.select("#naka_p").attr("transform", rr);
			}
		}

		// sodium-calcium-exchanger
		nacae = function(im, t) {
			// note: always rotate half way
			var BIND = 0;     // phase 0: bind ions
			var ROTATE = 1;   // phase 1: rotate
			var RELEASE = 2;  // phase 2: release ions
			var reversed = false;
			var pumpAngleStart = 45;
			var pumpAngleTurn = 180;
			var pump = im.select("#nacae_p");			

			var cdur, pdur;
			var phase;
			var cphase, pphase;

			// normal from t = 0 to t = 16
			// reversed from t = 16 to t = 166
			// normal from t = 166 to t = 300
			var tr1 = 16; // time of first reversal
			var tr2 = 166; // time of second reversal
			if (t < tr1) {
				// just one release phase before cycle is reverted
				phase = RELEASE;
				pdur = tr1;
				reversed = false;
				pphase = clip01(1.0 * t / (pdur - 1));
			} else if (t < tr2) {
				cdur = 48;
				pdur = Math.round(cdur / 3.0);
				reversed = true;
				cphase = (t-tr1) % cdur;
				phase = Math.floor(cphase / pdur);
				pphase = clip01((cphase % pdur) / (pdur-1));
			} else {
				cdur = 48;
				pdur = Math.round(cdur / 3.0);
				reversed = false;
				cphase = (t-tr2) % cdur;
				phase = Math.floor(cphase / pdur);
				pphase = clip01((cphase % pdur) / (pdur-1));
			}
			

			var pumpAngle;
			var caPath, caPer;
			var naPath, naPer;

			if (reversed) {
				pphase = 1 - pphase; // do all phases in reverse
				// swap bind and release phases
				var tmp = BIND;
				BIND = RELEASE;
				RELEASE = tmp;
			}

			if (phase == BIND) {
				pumpAngle = pumpAngleStart;
				caPath = "nacaeIp_cai";
				caPer = pphase;
				naPath = "nacaeIp_nai";
				naPer = pphase;
			} else if (phase == ROTATE) {
				pumpAngle = pumpAngleStart - pumpAngleTurn * pphase;
				caPath = "nacaeIp_cai";
				caPer = 1;
				naPath = "nacaeIp_nai";
				naPer = 1;
			} else if (phase == RELEASE) {
				pumpAngle = pumpAngleStart;
				caPath = "nacaeIp_cao";
				caPer = pphase;
				naPath = "nacaeIp_nao";
				naPer = pphase;
			}
			
			// rotate pump
			var rot = "r "+(pumpAngle)+" "+rot_centers["nacae_p"].join(",");
			pump.attr("transform", rot);

			// move ions
			moveIonsSingle(im, caPer, caPath+"_", "nacaeI_ca_");
			moveIonsSingle(im, naPer, naPath+"_", "nacaeI_na_");

			if (phase == ROTATE) {
				rot = "r "+(pumpAngle - pumpAngleStart)+" "+rot_centers["nacae_p"].join(",");
				// rotate ions with pump
				transformIons(im, "nacaeI_ca_", rot + " r 45");
				transformIons(im, "nacaeI_na_", rot);
			}
		}

		//potassium leak channels
		kl = function(im, t) {
			// we only need to move ions, because the channel is open anyway
			var ionPer = periods(0, tend, 4);
			moveIons(im, t, ionPer, "klIp_", "klI_");
		}

		// calcium-activated potassium channels
		caap = function(im, t) {
			var act = [138, 150, 400, 410];
			var pact = rectRamp(t, act);
			
			morph(pact, im.select("#caap_l").node.pathSegList, startPaths["caap_l"], endPaths["caap_l"]);
			morph(pact, im.select("#caap_r").node.pathSegList, startPaths["caap_r"], endPaths["caap_r"]);

			var ionPer = periods(150, 300, 4);
			moveIons(im, t, ionPer, "caapIp_", "caapI_");

			var start_ca = 100;
			var end_ca = 138;
			var pca = 1.0 * (t - start_ca) / (end_ca - start_ca)
			pca = clip01(pca);
			setOnPath(pca, im.select("#caap_ca"), animPaths["caap_ca"]);
		}

		transformIons = function (image, xml_prefix, trans_str) {
			forEachWithId(image, xml_prefix, function(ion) {
				ion.attr("transform", trans_str);
			});
		}

		moveIonsSingle = function (image, per, path_prefix, xml_prefix) {
			forEachWithId(image, xml_prefix, function(ion, i) {
				setOnPath(per, ion, animPaths[path_prefix + i]);
			}, true);
		}

		moveIons = function(image, t, periods, path_prefix, xml_prefix) {
			forEachWithId(image, xml_prefix, function(ion, i) {
				var k = path_prefix + i;
				moveAlongPath(t, addOff(periods, pOffs[k]), ion, animPaths[k]);
			}, true);
		}

		updateAnim = function(im, t) {
			// update time slider
			morph(1.0 * t / tend, im.select("#time0").node.pathSegList, startPaths["t"], endPaths["t"]);
			fna(im, t);
			cal(im, t);
			ir(im, t);
			to(im, t);
			dr(im, t);
			naka(im, t);
			nacae(im, t);
			kl(im, t);
			caap(im, t);
			slider.value = t;
			$('#sliderT').text(Math.round(t)+' ms');
		}

		setTime = function(t) {
			if (anim) {
				anim.stop();
				anim = null;	
			}
			updateAnim(sglob, t);
		}

		playPause = function() {
			if(anim) {
				anim.stop();
				anim = null;
			} else {
				var left = animDur * (1.0 - 1.0 * slider.value / tend)
				anim = Snap.animate(slider.value, tend, function(t) { updateAnim(sglob, t); }, left);
			}
		}
		
		window.onload = function() {
			var s = Snap("#svg");
			Snap.load("ion_channels_animation_pacemaker_base.svg", function(f) {
				setStartStates(f);
				s.append(f.select("g"));
			});
			sglob = s;
			slider = document.getElementById('slider');
			slider.min = t0;
			slider.max = tend;
		}
	</script>
</head>
<body>
	<svg id="svg" style="width:1000px;height:500px;">
	</svg>
	<div>
		<div>
			<input id="slider" type="range" name="time" min="0" max="300" value="0" oninput="setTime(this.value)"/> <span id="sliderT">0 ms</span>
		</div>
		<input type="button" name="playPause" onclick="playPause()" value="Play/Pause"/>
	</div>
</body>
</html>